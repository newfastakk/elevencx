<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Vant и Vue -->
  <link rel="stylesheet" href="https://unpkg.com/vant@2.12/lib/index.css"/>
  <script src="https://unpkg.com/vue@2.6/dist/vue.min.js"></script>
  <script src="https://unpkg.com/vant@2.12/lib/vant.min.js"></script>
  <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
  <!-- Шрифт SF Pixelate -->
  <link href="https://fonts.cdnfonts.com/css/sf-pixelate" rel="stylesheet">
  
  <style>
    /* Сброс отступов и боксов */
    * { padding: 0; margin: 0; box-sizing: border-box; }
    /* Запрет выделения текста (кроме input/textarea/checkbox) */
    *:not(input, checkbox, textarea) {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    /* Убираем фон страницы */
    body {
      background: transparent;
      font-family: 'SF Pixelate', sans-serif;
      color: #ffffff;
    }
    /* Canvas занимает весь экран */
    #cav {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    /* Ватермарк */
    #watermark {
      position: fixed;
      top: 5px;
      right: 5px;
      color: #0aff0a;
      background: rgba(20,20,20,0.7);
      border: 1px solid #0aff0a;
      padding: 5px 10px;
      z-index: 1000;
      font-size: 14px;
      pointer-events: none;
    }
    /* Меню */
    .aymenu {
      position: fixed;
      width: 380px;
      height: 300px;
      top: calc(50% - 150px);
      left: calc(50% - 190px);
      z-index: 999;
      background-color: #141414;
      border: 4px solid #0aff0a;
      border-radius: 10px;
      overflow: hidden;
      user-select: none;
    }
    .fun-block__title {
      padding: 32px 16px 16px;
      color: #8ee98e;
      font-size: 14px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .menuBody {
      overflow-y: auto;
      padding-bottom: 40px;
    }
    .van-nav-bar { background-color: #101010 !important; }
    .van-button--primary {
      background-color: #0aff0a !important;
      border-color: #0aff0a !important;
      color: #141414 !important;
    }
    .van-icon { color: #0aff0a !important; }
    .color-field .van-field__control { padding-left: 0 !important; }
  </style>
  
  <script>
    // Глобальная переменная для frida-скрипта
    var script;
    
    $(document).ready(function(){
      var canvas = document.querySelector("#cav"); 
      var ctx = canvas.getContext("2d", { alpha: false, desynchronized: false });
      window.gRoles = [];
      
      function startdraw() {
        let dpr = window.devicePixelRatio;
        let cw = canvas.width, ch = canvas.height;
        ctx.clearRect(0, 0, cw, ch);
        
        // Примерный watermark-текст (base64 в fillText)
        ctx.textBaseline = "top";
        ctx.textAlign = "center";
        ctx.fillStyle = "white";
        ctx.font = '50px "SF Pixelate", sans-serif';
        ctx.fillText(atob("aHR0cHM6Ly90Lm1lL2VMZXZlblhfY2hlYXRz"), cw/2, 50);
        
        // Параметры glow
        let glowRadius = app.VisualSlider.GlowRadius || 10;
        let glowColor = app.VisualColors.glowColor || app.VisualColors.boxColor;
        
        // Обходим все объекты для ESP
        for (let i = 0; i < gRoles.length; i++) {
          let x = gRoles[i].x * dpr;
          let y = gRoles[i].y * dpr;
          let z = gRoles[i].z * dpr;
          
          // ESP Box
          if (app.VisualCheckbox.ESPBox) {      
            let w = 2800/z, h = 5000/z;
            ctx.lineWidth = app.VisualSizes.boxThickness;
            ctx.strokeStyle = app.VisualColors.boxColor || "white";
            ctx.fillStyle = app.VisualColors.boxFill || "rgba(255,255,255,0.5)";
            
            if (app.VisualCheckbox.ESPBoxType == 1) {
              // Обычный прямоугольник (рамка)
              ctx.strokeRect(x - w/2, y - h/2, w, h);
            }
            else if (app.VisualCheckbox.ESPBoxType == 2) {
              // Полностью залитый
              ctx.fillRect(x - w/2, y - h/2, w, h);
            }
            else if (app.VisualCheckbox.ESPBoxType == 3) {
              // Рамка + заливка
              ctx.strokeRect(x - w/2, y - h/2, w, h);
              ctx.fillRect(x - w/2, y - h/2, w, h);
            }
            else if (app.VisualCheckbox.ESPBoxType == 4) {
              // Углы (Corner) #1
              let offset = 10;
              // 4 маленьких угла
              ctx.beginPath();
              // Левый верх
              ctx.moveTo(x - w/2, y - h/2 + offset);
              ctx.lineTo(x - w/2, y - h/2);
              ctx.lineTo(x - w/2 + offset, y - h/2);
              // Правый верх
              ctx.moveTo(x + w/2, y - h/2 + offset);
              ctx.lineTo(x + w/2, y - h/2);
              ctx.lineTo(x + w/2 - offset, y - h/2);
              // Левый низ
              ctx.moveTo(x - w/2, y + h/2 - offset);
              ctx.lineTo(x - w/2, y + h/2);
              ctx.lineTo(x - w/2 + offset, y + h/2);
              // Правый низ
              ctx.moveTo(x + w/2, y + h/2 - offset);
              ctx.lineTo(x + w/2, y + h/2);
              ctx.lineTo(x + w/2 - offset, y + h/2);
              ctx.stroke();
            }
            else if (app.VisualCheckbox.ESPBoxType == 5) {
              // Второй вариант «углов» (Corner #2), вместо прежнего "triangle"
              let offset = 20;
              ctx.beginPath();
              // Чуть более длинные углы, можно с другим стилем
              // Левый верх
              ctx.moveTo(x - w/2, y - h/2 + offset);
              ctx.lineTo(x - w/2, y - h/2);
              ctx.lineTo(x - w/2 + offset, y - h/2);
              // Правый верх
              ctx.moveTo(x + w/2, y - h/2 + offset);
              ctx.lineTo(x + w/2, y - h/2);
              ctx.lineTo(x + w/2 - offset, y - h/2);
              // Левый низ
              ctx.moveTo(x - w/2, y + h/2 - offset);
              ctx.lineTo(x - w/2, y + h/2);
              ctx.lineTo(x - w/2 + offset, y + h/2);
              // Правый низ
              ctx.moveTo(x + w/2, y + h/2 - offset);
              ctx.lineTo(x + w/2, y + h/2);
              ctx.lineTo(x + w/2 - offset, y + h/2);
              ctx.stroke();
            }
            else if (app.VisualCheckbox.ESPBoxType == 6) {
              // Pulse ESP (пульсирующая рамка)
              let pulse = (Math.sin(Date.now()/500)+1)/2;
              ctx.save();
              ctx.globalAlpha = 0.5 + 0.5 * pulse;
              ctx.strokeRect(x - w/2, y - h/2, w, h);
              ctx.restore();
            }
          }
          
          // China Hat (с учётом типа)
          if (app.VisualCheckbox.ESPChinaHat) {
            let hatScale = app.VisualSlider.ESPChinaHatScale || 1;
            ctx.save();
            ctx.strokeStyle = app.VisualColors.boxColor || "white";
            ctx.lineWidth = app.VisualSizes.boxThickness;
            
            if (app.VisualCheckbox.ESPChinaHatType == 1) {
              // Простой «китайский колпак» (было изначально)
              ctx.beginPath();
              ctx.moveTo(x - 50*hatScale, y - 60*hatScale);
              ctx.lineTo(x, y - 100*hatScale);
              ctx.lineTo(x + 50*hatScale, y - 60*hatScale);
              ctx.stroke();
            } 
            else if (app.VisualCheckbox.ESPChinaHatType == 2) {
              // Второй вариант: более пологая «шапка»
              ctx.beginPath();
              ctx.moveTo(x - 60*hatScale, y - 50*hatScale);
              ctx.lineTo(x, y - 80*hatScale);
              ctx.lineTo(x + 60*hatScale, y - 50*hatScale);
              ctx.closePath();
              ctx.stroke();
            }
            else if (app.VisualCheckbox.ESPChinaHatType == 3) {
              // Третий вариант: «шапка» с небольшим козырьком
              ctx.beginPath();
              ctx.moveTo(x - 40*hatScale, y - 50*hatScale);
              ctx.lineTo(x, y - 90*hatScale);
              ctx.lineTo(x + 40*hatScale, y - 50*hatScale);
              ctx.lineTo(x + 30*hatScale, y - 40*hatScale);
              ctx.lineTo(x - 30*hatScale, y - 40*hatScale);
              ctx.closePath();
              ctx.stroke();
            }
            
            ctx.restore();
          }
          
          // ESP Line
          if (app.VisualCheckbox.ESPLine) {
            ctx.beginPath();
            ctx.lineWidth = app.VisualSizes.lineThickness;
            ctx.strokeStyle = app.VisualColors.lineColor || "white";
            if (app.VisualCheckbox.ESPLineType == 1)
              ctx.moveTo(cw/2, 0);
            else if (app.VisualCheckbox.ESPLineType == 2)
              ctx.moveTo(cw/2, ch/2);
            else if (app.VisualCheckbox.ESPLineType == 3)
              ctx.moveTo(cw/2, ch);
            ctx.lineTo(x, y);
            ctx.stroke();
          }
          
          // ESP Distance
          if (app.VisualCheckbox.ESPDistance) {
            ctx.fillStyle = app.VisualColors.distanceColor || "white";
            ctx.font = app.VisualSizes.distanceFont + 'px "SF Pixelate", sans-serif';
            ctx.fillText("[" + Math.floor(z) + "M]", x, y);
          }
          
          // ESP Skeleton
          if (app.VisualCheckbox.ESPSkeleton) {
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = app.VisualColors.skeletonColor || "#ff0000";
            if (app.VisualCheckbox.ESPSkeletonType == 1) {
              // T Pose
              ctx.moveTo(x - 20, y);
              ctx.lineTo(x + 20, y);
              ctx.moveTo(x, y);
              ctx.lineTo(x, y - 40);
            } 
            else if (app.VisualCheckbox.ESPSkeletonType == 2) {
              // Крест
              ctx.moveTo(x - 15, y - 15);
              ctx.lineTo(x + 15, y + 15);
              ctx.moveTo(x + 15, y - 15);
              ctx.lineTo(x - 15, y + 15);
            } 
            else if (app.VisualCheckbox.ESPSkeletonType == 3) {
              // Псевдо-анимация
              let angle = Date.now()/200 % (2*Math.PI);
              ctx.moveTo(x, y);
              ctx.lineTo(x + 30 * Math.cos(angle), y + 30 * Math.sin(angle));
            }
            ctx.stroke();
          }
          
          // ESP Trail
          if (app.VisualCheckbox.ESPTrail) {
            let centerX = cw / 2, centerY = ch / 2;
            let trailFOV = app.VisualSlider.trailFOV;
            let angle = Math.atan2(y - centerY, x - centerX);
            let posX = centerX + trailFOV * Math.cos(angle);
            let posY = centerY + trailFOV * Math.sin(angle);
            ctx.save();
            ctx.translate(posX, posY);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(-10, 10);
            ctx.lineTo(10, 10);
            ctx.closePath();
            ctx.fillStyle = app.VisualColors.trailColor || "rgba(255,255,255,0.3)";
            ctx.fill();
            ctx.restore();
          }
          
          // ESP Glow
          if (app.VisualCheckbox.ESPGlow) {
            ctx.save();
            ctx.shadowBlur = glowRadius;
            ctx.shadowColor = glowColor;
            ctx.strokeStyle = app.VisualColors.boxColor;
            ctx.lineWidth = 3;
            let w = 2800/z, h = 5000/z;
            ctx.strokeRect(x - w/2, y - h/2, w, h);
            ctx.restore();
          }
        }
        
        // Отрисовка круга (если включён)
        if (app.VisualCheckbox.Circle) {
          ctx.beginPath();
          ctx.lineWidth = app.VisualSizes.circleThickness;
          ctx.strokeStyle = app.VisualColors.circleColor || 'red';
          ctx.arc(cw/2, ch/2, app.VisualSlider.CircleRadiusSlider, 0, Math.PI*2);
          ctx.stroke();
        }
        
        // Прицел (Crosshair) в Misc
        if (app.MiscCheckbox.Crosshair) {
          let centerX = cw/2, centerY = ch/2;
          let length = app.MiscSlider.AimLength;
          let thickness = app.MiscSlider.AimThickness;
          let gap = app.MiscSlider.AimDistance;
          ctx.save();
          ctx.lineWidth = thickness;
          ctx.strokeStyle = app.MiscColor.aimColor || "#ffffff";
          // Горизонтальные линии
          ctx.beginPath();
          ctx.moveTo(centerX - gap - length, centerY);
          ctx.lineTo(centerX - gap, centerY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(centerX + gap, centerY);
          ctx.lineTo(centerX + gap + length, centerY);
          ctx.stroke();
          // Вертикальные линии
          ctx.beginPath();
          ctx.moveTo(centerX, centerY - gap - length);
          ctx.lineTo(centerX, centerY - gap);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(centerX, centerY + gap);
          ctx.lineTo(centerX, centerY + gap + length);
          ctx.stroke();
          ctx.restore();
        }
      }
      
      setInterval(startdraw, 30);
    });
  </script>
  
  <!-- Frida блок остаётся без изменений, кроме вставки вашего кода как есть -->
  <script>
    function DrawESP() {
      if(app.VisualCheckbox.ESPEnable == false) { 
        if(typeof script !== "undefined" && script.call) {
          script.call("startDraw"); 
        }
      } else {
        if(typeof script !== "undefined" && script.call) {
          script.call("stopDraw"); 
        }
        return;
      }
    }
    
    function recv_frida_data(payload) {
      if(payload.type == "draw") 
        gRoles = payload.data;
      else if(payload.type == "error") 
        script.call("startDraw");
    }
    
    h5gg.require(7.9);
    let h5frida = h5gg.loadPlugin("h5frida", "/Library/MobileSubstrate/DynamicLibraries/h5frida-16.0.10.dylib");
    if (!h5frida && !(h5frida = h5gg.loadPlugin("h5frida", "h5frida-16.0.10.dylib"))) {
      throw "加载h5frida插件失败\n\nFailed to load h5frida plugin";
    }
    alert("frida plugin version=" + h5frida.pluginVersion() + "\nfrida core version=" + h5frida.coreVersion());
    let gadget = h5frida.loadGadget("frida-gadget-16.0.10.dylib");
    if (!gadget) throw "加载frida-gadget守护模块失败\n\nFailed to load frida-gadget daemon module";
    let procs = h5frida.enumerate_processes();
    if (!procs || !procs.length) {
      throw "frida无法获取进程列表\n\nfrida can't get process list";
    }
    let pid = -1;
    try { pid = h5gg.getProcList("STANDLEO")[0].pid; } catch (e) {}
    let found = false;
    for (let i = 0; i < procs.length; i++) {
      if (procs[i].pid == pid) { found = true; }
    }
    if (!found) throw "frida无法找到目标进程\n\nfrida cannot find the target process";
    let session = h5frida.attach(pid);
    if (!session) throw "frida附加进程失败\n\nfrida attach process failed";
    session.on("detached", function (reason) {
      alert("frida目标进程会话已终止(frida target process session terminated):\n" + reason);
    });
    let frida_script_code = "(" + frida_script.toString() + ")()";
    script = session.create_script(frida_script_code);
    if (!script) throw "frida注入脚本失败\n\nfrida inject script failed!";
    script.on('message', function (msg) {
      if (msg.type == 'error') {
        script.unload();
        alert("frida(脚本错误)script error:\n" + JSON.stringify(msg, null, 1).replaceAll("\\n", "\n"));
      }
      if (msg.type == 'send') {
        recv_frida_data(msg.payload);
      }
    });
    if (!script.load()) throw "frida启动脚本失败\n\nfrida load script failed";
    setTimeout(function () { script.call("init_via_il2cpp_api"); }, 1000);
    setTimeout(function () { script.call("getdata"); }, 5000);
    
    function frida_script() {
      if (arguments.length) return new Error().line;
      console.log("frida js running...");
      global.erroreport = function (info) { send({ type: "error", data: info }); };
      function load_il2cpp_api(returenType, apiName, argTypes, wrapper) {
        let f = Module.findExportByName(null, apiName);
        if (!f) throw "cannot find il2cpp api:" + apiName;
        global[apiName] = wrapper.bind(new NativeFunction(f, returenType, argTypes));
      }
      function load_il2cpp_icall(returenType, method, argTypes, wrapper) {
        let f = il2cpp_resolve_icall(method);
        if (!f) throw "cannot find il2cpp icall:" + method;
        global[wrapper.name] = wrapper.bind(new NativeFunction(f, returenType, argTypes));
      }
      function load_corlib_method(returenType, namespaze, clazz, name, argTypes, is_static, wrapper) {
        let corlib = il2cpp_get_corlib();
        let assemblyClass = il2cpp_class_from_name(corlib, namespaze, clazz);
        let il2cppmethod = il2cpp_class_get_method_from_name(assemblyClass, name, is_static ? argTypes.length : (argTypes.length - 1));
        if (il2cppmethod.isNull()) throw "cannot find corlib method:" + namespaze + "." + clazz + "." + name;
        let methodPointer = il2cppmethod.readPointer();
        global[wrapper.name] = wrapper.bind(new NativeFunction(methodPointer, returenType, argTypes));
      }
      rpc.exports.init_via_il2cpp_api = function() {
        load_il2cpp_api("pointer", "il2cpp_domain_get", [], function() { return this(); });
        load_il2cpp_api("pointer", "il2cpp_thread_attach", ["pointer"], function(domain) { return this(domain); });
        load_il2cpp_api("pointer", "il2cpp_string_new", ["pointer"], function(str) { return this(Memory.allocUtf8String(str)); });
        load_il2cpp_api("pointer", "il2cpp_get_corlib", [], function() { return this(); });
        load_il2cpp_api("pointer", "il2cpp_class_from_name", ["pointer", "pointer", "pointer"], function(image, namespaze, name) {
          return this(image, Memory.allocUtf8String(namespaze), Memory.allocUtf8String(name));
        });
        load_il2cpp_api("pointer", "il2cpp_class_get_method_from_name", ["pointer", "pointer", "int"], function(klass, name, argsCount) {
          return this(klass, Memory.allocUtf8String(name), argsCount);
        });
        load_il2cpp_api("pointer", "il2cpp_resolve_icall", ["pointer"], function(name) {
          return this(Memory.allocUtf8String(name));
        });
        /********************************************************************************/
        load_il2cpp_icall("pointer", "UnityEngine.Object::FindObjectsOfType(System.Type)", ["pointer"], function FindObjectsOfType(type) { return this(type); });
        console.log("invoke for delay...");
        load_il2cpp_icall("pointer", "UnityEngine.Object::ToString()", ["pointer"], function ToString(object) {
          return this(object).add(0x14).readUtf16String();
        });
        load_il2cpp_icall("pointer", "UnityEngine.Object::GetName(UnityEngine.Object)", ["pointer"], function GetName(object) {
          return this(object).add(0x14).readUtf16String();
        });
        load_il2cpp_icall("int", "UnityEngine.Object::GetOffsetOfInstanceIDInCPlusPlusObject()", [], function GetOffsetOfInstanceIDInCPlusPlusObject() {
          return this();
        });
        load_il2cpp_icall("int", "UnityEngine.SceneManagement.SceneManager::get_sceneCount()", [], function get_sceneCount(object) { return this(); });
        load_il2cpp_icall("pointer", "UnityEngine.GameObject::GetComponentsInternal(System.Type,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Object)",
          ["pointer", "pointer", "bool", "bool", "bool", "bool", "pointer"],
          function GetComponents(gameObject, type, useSearchTypeAsArrayReturnType, recursive, includeInactive, reverse, resultList) {
            return this(gameObject, type, useSearchTypeAsArrayReturnType, recursive, includeInactive, reverse, resultList);
          });
        load_il2cpp_icall("bool", "UnityEngine.GameObject::get_activeInHierarchy()", ["pointer"], function get_activeInHierarchy(gameObject) {
          return this(gameObject);
        });
        load_il2cpp_icall("pointer", "UnityEngine.GameObject::get_transform()", ["pointer"], function get_transform(gameObject) {
          return this(gameObject);
        });
        load_il2cpp_icall("void", "UnityEngine.Transform::get_position_Injected(UnityEngine.Vector3&)", ["pointer", "pointer"], function get_position(transform) {
          let vector = Memory.alloc(4*3);
          this(transform, vector);
          return {x: vector.readFloat(), y: vector.add(4).readFloat(), z: vector.add(8).readFloat()};
        });
        load_il2cpp_icall("pointer", "UnityEngine.Component::get_gameObject()", ["pointer"], function get_gameObject(component) {
          return this(component);
        });
        load_il2cpp_icall("int", "UnityEngine.Camera::GetAllCamerasCount()", [], function GetAllCamerasCount() { return this(); });
        load_il2cpp_icall("pointer", "UnityEngine.Camera::get_main()", [], function get_mainCamera() { return this(); });
        load_il2cpp_icall("void", "UnityEngine.Camera::WorldToViewportPoint_Injected(UnityEngine.Vector3&,UnityEngine.Camera/MonoOrStereoscopicEye,UnityEngine.Vector3&)",
          ["pointer", "pointer", "int", "pointer"],
          function WorldToViewportPoint(camera, location, eye) {
            let ret = Memory.alloc(4*3);
            this(camera, location, eye, ret);
            return {x: ret.readFloat(), y: ret.add(4).readFloat(), z: ret.add(8).readFloat()};
          });
        load_il2cpp_icall("void", "UnityEngine.Camera::WorldToScreenPoint_Injected(UnityEngine.Vector3&,UnityEngine.Camera/MonoOrStereoscopicEye,UnityEngine.Vector3&)",
          ["pointer", "pointer", "int", "pointer"],
          function WorldToScreenPoint(camera, location, eye) {
            let ret = Memory.alloc(4*3);
            this(camera, location, eye, ret);
            return {x: ret.readFloat(), y: ret.add(4).readFloat(), z: ret.add(8).readFloat()};
          });
        /********************************************************************************/
        let domain = il2cpp_domain_get();
        il2cpp_thread_attach(domain);
        load_corlib_method("pointer", "System.Reflection", "Assembly", "Load", ["pointer"], true, function assemblyLoad(assemblyString) {
          return this(il2cpp_string_new(assemblyString));
        });
        load_corlib_method("pointer", "System.Reflection", "Assembly", "GetType", ["pointer", "pointer"], false, function assemblyGetType(assembly, name) {
          return this(assembly, il2cpp_string_new(name));
        });
        load_corlib_method("pointer", "System", "Type", "GetMethod", ["pointer", "pointer"], false, function typeGetMethod(type, name) {
          return this(type, il2cpp_string_new(name));
        });
        /********************************************************************************/
        return true;
      }
      
      let screenFrame = ObjC.classes.UIApplication.sharedApplication().keyWindow().frame();
      let screenSize = { width: screenFrame[1][0], height: screenFrame[1][1] };
      
      let WorldToScreen = function(position) {
        if(get_mainCamera()) {
          let vector = Memory.alloc(4*3);
          vector.writeFloat(position.x);
          vector.add(4).writeFloat(position.y);
          vector.add(8).writeFloat(position.z);
          let pos = WorldToViewportPoint(get_mainCamera(), vector, 2);
          if(pos.z > 0) {
            pos.x *= screenSize.width;
            pos.y = screenSize.height*(1-pos.y);
          }
          return pos;
        }
      }
      
      rpc.exports.getdata = function() {
        try { return getdata(); } catch(e) { erroreport(e) }
      }
      
      global.getdata = function() {
        global.OffsetOfInstanceIDInCPlusPlusObject = GetOffsetOfInstanceIDInCPlusPlusObject();
        let showObjectArray = [];
        let UnityEngineAssembly = assemblyLoad("UnityEngine");
        let GameObjectType = assemblyGetType(UnityEngineAssembly, "UnityEngine.GameObject");
        let ComponentType = assemblyGetType(UnityEngineAssembly, "UnityEngine.Component");
        let gameObjectArray = FindObjectsOfType(GameObjectType);
        let gameObjectCount = gameObjectArray.add(0x18).readLong();
        let gameObjects = [];
        let componentTypes = [];
        let componentInfos = [];
        for(let i = 0; i < gameObjectCount; i++) {
          let object = gameObjectArray.add(0x20 + i * 8).readPointer();
          let activeInHierarchy = get_activeInHierarchy(object);
          let componentArray = GetComponents(object, ComponentType, 0, 0, 0, 0, ptr(0));
          let componentCount = componentArray.add(0x18).readLong();
          let transform = get_transform(object);
          let position = get_position(transform);
          let zeroPosition = (position.x == 0 && position.y == 0 && position.z == 0);
          if(activeInHierarchy && !zeroPosition && componentCount > 1) {
            let objname = GetName(object);
            let InstanceID = object.add(0x10).readPointer().add(OffsetOfInstanceIDInCPlusPlusObject).readInt();
            let componentArray = GetComponents(object, ComponentType, 0, 0, 0, 0, ptr(0));
            let componentCount = componentArray.add(0x18).readLong();
            let transform = get_transform(object);
            let position = get_position(transform);
            let go_components = [];
            for(let n = 0; n < componentCount; n++) {
              let comp = componentArray.add(0x20 + n * 8).readPointer();
              if(comp.isNull()) continue;
              let _pclass = comp.readPointer();
              let _image = _pclass.readPointer().readPointer().readCString();
              let _klass = _pclass.add(0x10).readPointer().readCString();
              let _namespaze = _pclass.add(0x18).readPointer().readCString();
              let typeKey = _image + ":" + _namespaze + "." + _klass;
              let index = componentTypes.indexOf(typeKey);
              if(index == -1) {
                index = componentTypes.push(typeKey) - 1;
                componentInfos.push({
                  count: 0,
                  image: _image,
                  type: _namespaze.length ? (_namespaze + "." + _klass) : _klass
                });
              }
              componentInfos[index].count++;
              if(go_components.indexOf(index) == -1)
                go_components.push(index);
            }
            gameObjects.push([InstanceID, objname, go_components]);
          }
        }
        return {"gameObjectCount": gameObjectCount, "gameObjects": gameObjects, "components": componentInfos};
      }
      
      rpc.exports.startDraw = function() {
        try { return startDraw(); } catch(e) { erroreport(e); }
      }
      
      global.startDraw = function() {
        if(global.drawtimer) clearInterval(global.drawtimer);
        let UnityEngineAssembly = assemblyLoad("UnityEngine");
        let ComponentType = assemblyGetType(UnityEngineAssembly, "UnityEngine.Component");
        let ComponentFilterAssembly = assemblyLoad("Assembly-CSharp");
        let ComponentAllEnemies = assemblyGetType(ComponentFilterAssembly, "Axlebolt.Standoff.Player.Aim.AimController");
        function drawfunc() {
          if (!get_mainCamera() || get_mainCamera().isNull()) return;
          let showObjectArray = [];
          let ComponentFilterArray = FindObjectsOfType(ComponentAllEnemies);
          let ComponentFilterCount = ComponentFilterArray.add(0x18).readLong();
          for(let i = 0; i < ComponentFilterCount; i++) {
            let ComponentFilter = ComponentFilterArray.add(0x20 + i * 8).readPointer();
            let object = get_gameObject(ComponentFilter);
            let activeInHierarchy = get_activeInHierarchy(object);
            if(activeInHierarchy) {
              let transform = get_transform(object);
              let position = get_position(transform);
              let InstanceID = object.add(0x10).readPointer().add(OffsetOfInstanceIDInCPlusPlusObject).readInt();
              showObjectArray.push({ "id": InstanceID, "position": position });
            }
          }
          var trans = function() {
            let drawobjects = [];
            for(let i = 0; i < showObjectArray.length; i++) {
              let position = showObjectArray[i].position;
              let pos = WorldToScreen(position);
              if(pos.z > 1) {
                drawobjects.push({
                  id: showObjectArray[i].id,
                  x: pos.x,
                  y: pos.y,
                  z: pos.z
                });
              }
            }
            send({ type: "draw", data: drawobjects });
          }
          ObjC.schedule(ObjC.mainQueue, trans);
        }
        global.drawtimer = setInterval(function() {
          try {
            drawfunc();
          } catch(e) {
            clearInterval(global.drawtimer);
            erroreport(e);
          }
        }, 25);
        return true;
      }
      
      rpc.exports.stopDraw = function() {
        if(global.drawtimer) clearInterval(global.drawtimer);
        send({ type: "draw", data: [] });
      }
      
      rpc.exports.adjustDamage = function(multiplier) {
        try {
          console.log("Adjusting damage with multiplier: " + multiplier);
          var addresses = {
            head: ptr("0xCCB828"),
            stomach: ptr("0xCCB8B8"),
            chestArms: ptr("0xCCB858"),
            legs: ptr("0xCCB820")
          };
          for (var key in addresses) {
            var addr = addresses[key];
            var currentVal = Memory.readFloat(addr);
            Memory.writeFloat(addr, currentVal * multiplier);
          }
          var distAddr = ptr("0xCCB7EC");
          console.log("DistanceDamage current value: " + Memory.readFloat(distAddr));
          return true;
        } catch(e) {
          erroreport(e);
          return false;
        }
      }
    }
  </script>
</head>
<body>
  <!-- Watermark -->
  <div id="watermark">eLevenX.cc</div>
  
  <!-- Canvas -->
  <canvas id="cav" width="100%" height="100%" style="width:100%; height:100%;"></canvas>
  
  <!-- Vue-приложение с меню -->
  <div id="app">
    <div class="aymenu" ref="menuMain">
      <div @touchstart="titleTouchStart" @touchmove="titleTouchMove">
        <van-nav-bar>
          <template #title>
            <van-button type="primary" color="black" @click="changeTab('Global')" size="mini" plain>Global</van-button>
            <van-button type="primary" color="black" @click="changeTab('Visual')" size="mini" plain>Visual</van-button>
            <van-button type="primary" color="black" @click="changeTab('Misc')" size="mini" plain>Misc</van-button>
            <van-button type="primary" color="black" @click="changeTab('About')" size="mini" plain>About</van-button>
            <div id="popup_loadscripts" class="popup_view3"></div>
          </template>
          <template #right>
            <van-icon @click="closeMenu" name="close" size="20" />
          </template>
        </van-nav-bar>
      </div>
      <div class="menuBody" ref="menuBody">
        <div>
          <!-- Global вкладка -->
          <div v-show="tabValue==='Global'">
            <h2 class="fun-block__title" style="padding-top: 20px;"><center>Cheat By elevex.cc</center></h2>
            <van-cell-group inset>
              <van-checkbox v-model="GlobalCheckbox.DamageBoost" style="margin-left: 10px;" icon-size="25px">Damage Boost</van-checkbox>
              <br>
              <p style="margin-left: 10px;" v-if="GlobalCheckbox.DamageBoost">Damage Multiplier: {{ GlobalSlider.DamageMultiplier }}</p>
              <van-slider v-model="GlobalSlider.DamageMultiplier" style="margin:0 15px;" :min="1" :max="10" v-if="GlobalCheckbox.DamageBoost"></van-slider>
              
              <br>
              <!-- FireRate -->
              <van-checkbox v-model="GlobalCheckbox.FireRate" style="margin-left: 10px;" icon-size="25px">Fire Rate</van-checkbox>
              <br>
            </van-cell-group>
          </div>
          <!-- Visual вкладка -->
          <div v-show="tabValue==='Visual'">
            <h3 class="fun-block__title" style="padding-top: 20px;"><center>Cheat By elevex.cc</center></h3>
            <van-cell-group inset>
              <p class="content" style="padding-top: 10px;"><center>ESP</center></p>
              <br>
              <van-checkbox v-model="VisualCheckbox.ESPEnable" style="margin-left: 10px;" icon-size="25px" onclick="DrawESP()">ESP Enable</van-checkbox>
              <br>
              <van-checkbox v-model="VisualCheckbox.ESPBox" style="margin-left: 10px;" icon-size="25px">ESP Box</van-checkbox>
              <br>
              <p style="margin-left: 10px;">ESP Box Type:</p>
              <van-stepper style="margin-left: 10px;" v-model="VisualCheckbox.ESPBoxType" theme="round" button-size="25" :max="6" disable-input></van-stepper>
              <br>
              <van-checkbox v-model="VisualCheckbox.ESPLine" style="margin-left: 10px;" icon-size="25px">ESP Line</van-checkbox>
              <br>
              <p style="margin-left: 10px;">ESP Line Type:</p>
              <van-stepper style="margin-left: 10px;" v-model="VisualCheckbox.ESPLineType" theme="round" button-size="25" :max="3" disable-input></van-stepper>
              <br>
              <van-checkbox v-model="VisualCheckbox.ESPDistance" style="margin-left: 10px;" icon-size="25px">ESP Distance</van-checkbox>
              <br>
              <van-checkbox v-model="VisualCheckbox.ESPSkeleton" style="margin-left: 10px;" icon-size="25px">ESP Skeleton</van-checkbox>
              <br>
              <p style="margin-left: 10px;">Skeleton Type:</p>
              <van-stepper style="margin-left: 10px;" v-model="VisualCheckbox.ESPSkeletonType" theme="round" button-size="25" :min="1" :max="3" disable-input></van-stepper>
              <br>
              <van-checkbox v-model="VisualCheckbox.ESPTrail" style="margin-left: 10px;" icon-size="25px">ESP Trail</van-checkbox>
              <br>
              <p style="margin-left: 10px;">Trail FOV:</p>
              <van-slider v-model="VisualSlider.trailFOV" style="margin:0 15px;" :min="10" :max="200"></van-slider>
              <br>
              <van-checkbox v-model="VisualCheckbox.ESPGlow" style="margin-left: 10px;" icon-size="25px">ESP Glow</van-checkbox>
              <br>
              <p style="margin-left: 10px;">Glow Radius:</p>
              <van-slider v-model="VisualSlider.GlowRadius" style="margin:0 15px;" :min="5" :max="30"></van-slider>
              <br>
              <p style="margin-left: 10px;">Glow Strength:</p>
              <van-slider v-model="VisualSlider.GlowStrength" style="margin:0 15px;" :min="1" :max="10"></van-slider>
              <br>
              <van-checkbox v-model="VisualCheckbox.Circle" style="margin-left: 10px;" icon-size="25px">Circle</van-checkbox>
              <br>
              <p style="margin-left: 10px;">Circle Radius:</p>
              <van-slider v-model="VisualSlider.CircleRadiusSlider" style="width: 91%; margin-left: 15px;" :min="10" :max="200"></van-slider>
              <br>
              <!-- Размеры ESP-элементов -->
              <h4 style="margin-left: 10px;">ESP Element Sizes</h4>
              <p style="margin-left: 10px;">Box Thickness: {{ VisualSizes.boxThickness }}</p>
              <van-slider v-model="VisualSizes.boxThickness" style="margin:0 15px;" :min="1" :max="10"></van-slider>
              <p style="margin-left: 10px;">Line Thickness: {{ VisualSizes.lineThickness }}</p>
              <van-slider v-model="VisualSizes.lineThickness" style="margin:0 15px;" :min="1" :max="10"></van-slider>
              <p style="margin-left: 10px;">Distance Font Size: {{ VisualSizes.distanceFont }}</p>
              <van-slider v-model="VisualSizes.distanceFont" style="margin:0 15px;" :min="10" :max="30"></van-slider>
              <br>
              <!-- China Hat + типы -->
              <van-checkbox v-model="VisualCheckbox.ESPChinaHat" style="margin-left: 10px;" icon-size="25px">ESP China Hat</van-checkbox>
              <br>
              <p style="margin-left: 10px;">China Hat Scale: {{ VisualSlider.ESPChinaHatScale || 1 }}</p>
              <van-slider v-model="VisualSlider.ESPChinaHatScale" style="margin:0 15px;" :min="0.5" :max="3" :step="0.1"></van-slider>
              <br>
              <p style="margin-left: 10px;">China Hat Type:</p>
              <van-stepper style="margin-left: 10px;" v-model="VisualCheckbox.ESPChinaHatType" theme="round" button-size="25" :min="1" :max="3" disable-input></van-stepper>
              <br>
              <h4 style="margin-left: 10px;">ESP Colors</h4>
              <p style="margin-left: 10px;">Box Color: {{ VisualColors.boxColor }}</p>
              <van-field v-model="VisualColors.boxColor" placeholder="Например: #00ff00" clearable></van-field>
              <p style="margin-left: 10px;">Line Color: {{ VisualColors.lineColor }}</p>
              <van-field v-model="VisualColors.lineColor" placeholder="Например: #00ff00" clearable></van-field>
              <p style="margin-left: 10px;">Distance Color: {{ VisualColors.distanceColor }}</p>
              <van-field v-model="VisualColors.distanceColor" placeholder="Например: #00ff00" clearable></van-field>
              <p style="margin-left: 10px;">Skeleton Color: {{ VisualColors.skeletonColor || "#ff0000" }}</p>
              <van-field v-model="VisualColors.skeletonColor" placeholder="Например: #ff0000" clearable></van-field>
              <p style="margin-left: 10px;">Trail Color: {{ VisualColors.trailColor || "rgba(255,255,255,0.3)" }}</p>
              <van-field v-model="VisualColors.trailColor" placeholder="Например: rgba(255,255,255,0.3)" clearable></van-field>
              <p style="margin-left: 10px;">Glow Color: {{ VisualColors.glowColor || VisualColors.boxColor }}</p>
              <van-field v-model="VisualColors.glowColor" placeholder="Например: #00ff00" clearable></van-field>
              <p style="margin-left: 10px;">Circle Color: {{ VisualColors.circleColor }}</p>
              <van-field v-model="VisualColors.circleColor" placeholder="Например: #ff0000" clearable></van-field>
              <br>
              <van-checkbox v-model="GlobalCheckbox.FovHook" style="margin-left: 10px;" icon-size="25px" onclick="FovHookVoid()">Fov</van-checkbox>
              <br>
            </van-cell-group>
          </div>
          <!-- Misc вкладка -->
          <div v-show="tabValue==='Misc'">
            <h3 class="fun-block__title" style="padding-top: 20px;"><center>Misc Settings</center></h3>
            <van-cell-group inset>
              <!-- Прицел (Crosshair) в Misc -->
              <van-checkbox v-model="MiscCheckbox.Crosshair" style="margin-left: 10px;" icon-size="25px">Crosshair (Прицел)</van-checkbox>
              <br>
              <p style="margin-left: 10px;">Aim Length: {{ MiscSlider.AimLength }}</p>
              <van-slider v-model="MiscSlider.AimLength" style="margin:0 15px;" :min="10" :max="50"></van-slider>
              <p style="margin-left: 10px;">Aim Thickness: {{ MiscSlider.AimThickness }}</p>
              <van-slider v-model="MiscSlider.AimThickness" style="margin:0 15px;" :min="1" :max="10"></van-slider>
              <p style="margin-left: 10px;">Aim Gap: {{ MiscSlider.AimDistance }}</p>
              <van-slider v-model="MiscSlider.AimDistance" style="margin:0 15px;" :min="0" :max="20"></van-slider>
              <p style="margin-left: 10px;">Aim Color: {{ MiscColor.aimColor || "#ffffff" }}</p>
              <van-field v-model="MiscColor.aimColor" placeholder="Например: #ffffff" clearable></van-field>
            </van-cell-group>
          </div>
          <!-- About вкладка -->
          <div v-show="tabValue==='About'">
            <h3 class="fun-block__title" style="padding-top: 20px;"><center>Cheat By elevex.cc</center></h3>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- FOV дисплей (не изменялся) -->
  <div id="aimFovDisplay" style="position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%); color: white; font-size: 18px; padding: 5px; border: 1px solid white; background: rgba(0,0,0,0.5); display: none;">
    FOV: 90
  </div>
  
  <script>
    var app = new Vue({
      el: '#app',
      data() {
        return {
          GlobalCheckbox: {
            GodMode: 1, InVisible: 1, GravityOff: 1,
            SlowMove: false, LongJump: false, FastJump: false,
            LongJumpAutoJump: false, DeadTrigger: false, DontReturnSpawn: false,
            FriendlyFire: false, PlantAnyWhere: false, DefuseAnyWhere: false,
            BuyZoneAnyWhere: false, CameraOnlyNone: false, UseTouce: false,
            Pingq: false, FreezeWeapon: false, FreezeWeaponCanSeeOnlyOther: false,
            BulletTracking: false, WallShot: false, Bypass: false, AntiKick: false,
            FireRate: false, FovHook: false, ShakeOff: false, BunnyHopAutoJump: false,
            DamageBoost: false
          },
          VisualCheckbox: {
            ESPEnable: false,
            ESPBox: false,
            ESPLine: false,
            ESPDistance: false,
            Circle: false,
            ESPSkeleton: false,
            ESPBoxType: 1, // 1..6
            ESPLineType: 1,
            ESPSkeletonType: 1, // 1..3
            ESPTrail: false,
            ESPGlow: false,
            ESPChinaHat: false,
            ESPChinaHatType: 1 // 1..3
          },
          VisualSlider: {
            CircleRadiusSlider: 50,
            CrosshairSizeSlider: 10,
            GlowRadius: 10,
            GlowStrength: 5,
            trailFOV: 50,
            ESPChinaHatScale: 1
          },
          GlobalSlider: {
            DamageMultiplier: 1
          },
          VisualSizes: {
            boxThickness: 3,
            lineThickness: 2,
            distanceFont: 14,
            circleThickness: 2
          },
          VisualColors: {
            boxColor: "#00ff00",
            boxFill: "rgba(0,255,0,0.3)",
            lineColor: "#00ff00",
            distanceColor: "#00ff00",
            circleColor: "#00ff00",
            skeletonColor: "#ff0000",
            trailColor: "rgba(255,255,255,0.3)",
            glowColor: "#00ff00"
          },
          MiscCheckbox: {
            Crosshair: false
          },
          MiscSlider: {
            AimLength: 20,
            AimThickness: 2,
            AimDistance: 5
          },
          MiscColor: {
            aimColor: "#ffffff"
          },
          tabValue: "Global",
          touchStartX: 0,
          touchStartY: 0,
          menuLastX: 0,
          menuLastY: 0,
        }
      },
      mounted() {
        this.setRect(380, 300);
        setButtonImage("https://www.pngall.com/wp-content/uploads/15/iPhone-Assistive-Touch-PNG-Photo.png");
      },
      methods: {
        setRect(w, h, x = -1, y = -1) {
          var boxW = w, boxH = h;
          var ayMenu = this.$refs.menuMain;
          ayMenu.style.width = `${boxW}px`;
          ayMenu.style.height = `${boxH}px`;
          if (x == -1) ayMenu.style.left = `calc(50% - ${boxW/2}px)`;
          if (y == -1) ayMenu.style.top = `calc(50% - ${boxH/2}px)`;
          var menuBody = this.$refs.menuBody;
          menuBody.style.height = `${boxH - 46 - 40}px`;
        },
        titleTouchStart(event) {
          this.touchStartX = parseInt(event.touches[0].clientX);
          this.touchStartY = parseInt(event.touches[0].clientY);
          var ayMenu = this.$refs.menuMain;
          this.menuLastX = ayMenu.offsetLeft;
          this.menuLastY = ayMenu.offsetTop;
        },
        titleTouchMove(event) {
          event.preventDefault();
          var distanceX = event.touches[0].clientX - this.touchStartX;
          var distanceY = event.touches[0].clientY - this.touchStartY;
          var ayMenu = this.$refs.menuMain;
          ayMenu.style.left = this.menuLastX + distanceX + "px";
          ayMenu.style.top = this.menuLastY + distanceY + "px";
        },
        changeTab(v) { this.tabValue = v; },
        closeMenu() {
          var menu = document.querySelector("#app");
          menu.style.display = "none";
          setWindowTouch(false);
        }
      },
      watch: {
        // Когда включают/выключают DamageBoost
        'GlobalSlider.DamageMultiplier': function(newVal) {
          if(this.GlobalCheckbox.DamageBoost) {
            if(typeof script !== "undefined" && script.call) {
              script.call("adjustDamage", newVal);
            }
          }
        },
        'GlobalCheckbox.DamageBoost': function(newVal) {
          if(newVal && typeof script !== "undefined" && script.call) {
            script.call("adjustDamage", this.GlobalSlider.DamageMultiplier);
          }
        },
        // Когда включают/выключают FireRate
        'GlobalCheckbox.FireRate': function(newVal) {
          if(newVal) {
            // Применяем настройки
            h5gg.searchNumber(0x2992ED8, 'f32', '0x0000000', '0x200000000');
            h5gg.editAll(20, 'F32');
            h5gg.clearResults();
          }
        }
      }
    });
    
    setWindowDrag(0, 0, 0, 0);
    var layout = function () {
      if (window.lastorientation == window.orientation) return;
      window.lastorientation = window.orientation;
      var canvas = document.querySelector("#cav");
      var scale = window.devicePixelRatio;
      if (Math.abs(window.orientation) == 90) {
        canvas.width = window.screen.height * scale;
        canvas.height = window.screen.width * scale;
        setWindowRect(0, 0, window.screen.height, window.screen.width);
      } else {
        canvas.width = window.screen.width * scale;
        canvas.height = window.screen.height * scale;
        setWindowRect(0, 0, window.screen.width, window.screen.height);
      }
    }
    layout();
    window.addEventListener("orientationchange", layout, false);
    setButtonAction(function () {
      var menu = document.querySelector("#app");
      if (menu.style.display == "none") {
        menu.style.display = "block";
        setWindowTouch(true);
      } else {
        menu.style.display = "none";
        setWindowTouch(false);
      }
    });
  </script>
</body>
</html>